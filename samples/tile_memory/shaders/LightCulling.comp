#version 460
//============================================================================================================
//
//
//                  Copyright (c) 2024, Qualcomm Innovation Center, Inc. All rights reserved.
//                              SPDX-License-Identifier: BSD-3-Clause
//
//============================================================================================================

#define MAX_LIGHT_COUNT 2048
#define MAX_TILE_MATRIX_DIMENSION_SIZE 8
#define MAX_TILE_MATRIX_SIZE (MAX_TILE_MATRIX_DIMENSION_SIZE * MAX_TILE_MATRIX_DIMENSION_SIZE)

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

struct LightUB
{
    vec4 lightPosAndRadius; // xyz = pos | w = radius
    vec4 lightColor;
};

struct SceneInfoUB
{
    mat4 projectionInv;
    mat4 view;
    mat4 viewInv;
    mat4 viewProjection;
    mat4 viewProjectionInv; // ViewInv * ProjectionInv
    vec4 projectionInvW;    // w components of ProjectionInv
    vec4 cameraPos;

    vec4 skyLightDirection;
    vec4 skyLightColor;

    vec4 ambientColor;

    uint viewportWidth;
    uint viewportHeight;
    uint clusterCountX;
    uint clusterCountY;
    int lightCount;
    int debugShaders;
    int ignoreLightTiles;
    int tileMemoryEnabled;
};

layout(set = 0, binding = 0, rgba32f) uniform highp readonly image2D u_DepthTex;

layout(std140, set = 0, binding = 1) uniform SceneInfo 
{
    SceneInfoUB sceneInfo;
};

layout(std140, set = 0, binding = 2) uniform Lights 
{
    LightUB lights[MAX_LIGHT_COUNT];
};

layout(std430, set = 0, binding = 3) buffer writeonly TileLightIndices
{
    uint lightIndices[];
};

layout(std430, set = 0, binding = 4) buffer writeonly TileLightCounts
{
    uint lightCounts[];
};

vec3 reconstructWorldPosition(highp vec2 uv, highp float depth)
{
    highp vec4 clipSpacePos = vec4(
        uv.x * 2.0 - 1.0,
        (1.0 - uv.y) * 2.0 - 1.0,
        depth,
        1.0
    );

    highp vec4 fragViewSpacePos = sceneInfo.projectionInv * clipSpacePos;
    fragViewSpacePos /= fragViewSpacePos.w;
    return (sceneInfo.viewInv * fragViewSpacePos).xyz;
}

void main() 
{
    //
    // NON-SHARED SECTION BEGIN
    //

    // How many clusters exist on the screen
    uint globalClusterCountX = sceneInfo.clusterCountX;
    uint globalClusterCountY = sceneInfo.clusterCountY;

    // Individual cluster size
    float clusterSizeX = float(sceneInfo.viewportWidth) / float(globalClusterCountX);
    float clusterSizeY = float(sceneInfo.viewportHeight) / float(globalClusterCountY);

    // Current cluster being processed now
    uint currentClusterIndexX = gl_GlobalInvocationID.x;
    uint currentClusterIndexY = gl_GlobalInvocationID.y;

    //
    // NON-SHARED SECTION END
    //
    // (everything below this is common code between the 2 compute shader versions)
    //

    uint clusterIndex = currentClusterIndexY * globalClusterCountX + currentClusterIndexX;

    // Tile bounds in pixels
    uint clusterMinX = uint(float(currentClusterIndexX) * clusterSizeX);
    uint clusterMinY = uint(float(currentClusterIndexY) * clusterSizeY);
    uint clusterMaxX = uint(float(clusterMinX) + clusterSizeX);
    uint clusterMaxY = uint(float(clusterMinY) + clusterSizeY);

    // Early exit if fully out of bounds
    if (clusterMinX >= sceneInfo.viewportWidth || clusterMinY >= sceneInfo.viewportHeight)
    {
        return;
    }

    // Reconstruct tile frustum
    highp vec3 clusterMin = vec3(1e8);
    highp vec3 clusterMax = vec3(-1e8);

    for (uint y = clusterMinY; y < clusterMaxY; ++y)
    {
        for (uint x = clusterMinX; x < clusterMaxX; ++x)
        {
            vec2 uv = vec2(float(x) / float(sceneInfo.viewportWidth), 
                           float(y) / float(sceneInfo.viewportHeight));
            if(uv.x > 1.0 || uv.y > 1.0)
            {
                continue;
            }

            ivec2 pixelLocation = ivec2(uv * vec2(sceneInfo.viewportWidth, sceneInfo.viewportHeight));

            highp float depth = imageLoad(u_DepthTex, pixelLocation).r * 2.0 - 1.0;
            vec3 worldPos = reconstructWorldPosition(uv, depth);

            clusterMin = min(clusterMin, worldPos);
            clusterMax = max(clusterMax, worldPos);
        }
    }

    uint tileLightCount = 0u;
    for (int lightId = 0; lightId < int(sceneInfo.lightCount); ++lightId)
    {
        vec3 lightPosition = lights[lightId].lightPosAndRadius.xyz;
        float lightRadius  = lights[lightId].lightPosAndRadius.w;

        // Test light against tile bounds (AABB vs Sphere)
        vec3 closestPoint = clamp(lightPosition, clusterMin, clusterMax);
        float distance = length(closestPoint - lightPosition);

        if (distance < lightRadius * 2.0)
        {
            lightIndices[clusterIndex * uint(MAX_LIGHT_COUNT) + tileLightCount] = uint(lightId);
            tileLightCount++;
        }
    }

    lightCounts[clusterIndex] = tileLightCount;
}